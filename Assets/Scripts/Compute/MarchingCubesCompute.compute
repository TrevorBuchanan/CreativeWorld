#pragma kernel GenerateMesh

// Input voxel grid
StructuredBuffer<float> VoxelGrid;

// Output vertices and triangles
RWStructuredBuffer<float3> Vertices; // Output vertex positions
RWStructuredBuffer<int> Triangles;   // Output triangle indices

// Parameters
int3 gridSize;
int divisions;
float isoLevel;

[numthreads(8, 8, 1)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    // Calculate voxel position
    int x = id.x;
    int y = id.y;
    int z = id.z;

    // Ensure we're within bounds
    if (x >= gridSize.x || y >= gridSize.y || z >= gridSize.z)
        return;

    // Get scalar values for the cube's corners
    float cornerValues[8];
    [unroll]
    for (int i = 0; i < 8; i++)
    {
        int3 cornerPos = GetCubeCornerPos(x, y, z, i);
        cornerValues[i] = VoxelGrid[cornerPos.z * gridSize.x * gridSize.y + cornerPos.y * gridSize.x + cornerPos.x];
    }

    // Determine cube index based on isoLevel
    int cubeIndex = 0;
    if (cornerValues[0] < isoLevel) cubeIndex |= 1;
    if (cornerValues[1] < isoLevel) cubeIndex |= 2;
    if (cornerValues[2] < isoLevel) cubeIndex |= 4;
    if (cornerValues[3] < isoLevel) cubeIndex |= 8;
    if (cornerValues[4] < isoLevel) cubeIndex |= 16;
    if (cornerValues[5] < isoLevel) cubeIndex |= 32;
    if (cornerValues[6] < isoLevel) cubeIndex |= 64;
    if (cornerValues[7] < isoLevel) cubeIndex |= 128;

    // Check if the cube contributes any geometry
    if (MarchingCubes.TriangleTable[cubeIndex][0] == -1)
        return;

    // Generate vertices and triangles
    for (int i = 0; MarchingCubes.TriangleTable[cubeIndex][i] != -1; i += 3)
    {
        int edgeIndices[3] = {
            MarchingCubes.TriangleTable[cubeIndex][i],
            MarchingCubes.TriangleTable[cubeIndex][i + 1],
            MarchingCubes.TriangleTable[cubeIndex][i + 2]
        };

        float3 triangleVertices[3];
        [unroll]
        for (int j = 0; j < 3; j++)
        {
            int v1 = MarchingCubes.EdgeVertexIndices[edgeIndices[j]][0];
            int v2 = MarchingCubes.EdgeVertexIndices[edgeIndices[j]][1];

            float3 p1 = GetCubeCornerPosFloat3(x, y, z, v1);
            float3 p2 = GetCubeCornerPosFloat3(x, y, z, v2);

            triangleVertices[j] = VertexInterpolate(p1, p2, cornerValues[v1], cornerValues[v2], isoLevel);
        }

        // Write triangle vertices and indices
        uint baseIndex = atomicAdd(TriangleCount, 3);
        Triangles[baseIndex + 0] = atomicAdd(VertexCount, 1);
        Triangles[baseIndex + 1] = atomicAdd(VertexCount, 1);
        Triangles[baseIndex + 2] = atomicAdd(VertexCount, 1);

        Vertices[Triangles[baseIndex + 0]] = triangleVertices[0];
        Vertices[Triangles[baseIndex + 1]] = triangleVertices[1];
        Vertices[Triangles[baseIndex + 2]] = triangleVertices[2];
    }
}

int3 GetCubeCornerPos(int x, int y, int z, int cornerIndex)
{
    int3 cornerOffsets[8] = {
        int3(0, 0, 0), int3(1, 0, 0), int3(0, 1, 0), int3(1, 1, 0),
        int3(0, 0, 1), int3(1, 0, 1), int3(0, 1, 1), int3(1, 1, 1)
    };
    return int3(x, y, z) + cornerOffsets[cornerIndex];
}

float3 GetCubeCornerPosFloat3(int x, int y, int z, int cornerIndex)
{
    float3 cornerOffsets[8] = {
        float3(0, 0, 0), float3(1, 0, 0), float3(0, 1, 0), float3(1, 1, 0),
        float3(0, 0, 1), float3(1, 0, 1), float3(0, 1, 1), float3(1, 1, 1)
    };
    return float3(x, y, z) + cornerOffsets[cornerIndex];
}

float3 VertexInterpolate(float3 p1, float3 p2, float v1, float v2, float isoLevel)
{
    if (abs(isoLevel - v1) < 0.00001)
        return p1;
    if (abs(isoLevel - v2) < 0.00001)
        return p2;
    if (abs(v1 - v2) < 0.00001)
        return p1;

    float t = (isoLevel - v1) / (v2 - v1);
    return lerp(p1, p2, t);
}

float3 lerp(float3 p1, float3 p2, float t)
{
    return p1 + t * (p2 - p1);
}
